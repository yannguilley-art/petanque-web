<!doctype html>
<html lang="fr">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1,viewport-fit=cover,user-scalable=no" />
<title>P√©tanque Web ‚Äî Mobile</title>
<style>
  :root{
    --bg:#0e0f13; --panel:#181a20; --ink:#e9eef8; --muted:#aab3c5;
    --blue:#2d7ef7; --red:#ff4d4f; --jack:#ffcf4a;
    --terrain:#c7b08a; --rail:#7a5d37;
  }
  *{ box-sizing:border-box; -webkit-tap-highlight-color: transparent; }
  html, body{ margin:0; height:100%; background:linear-gradient(180deg,var(--bg),#111319 35%); color:var(--ink);
              font:15px/1.45 system-ui, -apple-system, Segoe UI, Roboto; }
  body{ overscroll-behavior: none; -webkit-user-select:none; user-select:none; }
  .wrap{ max-width:1100px; margin: clamp(6px,2vw,18px) auto; padding: clamp(6px,2vw,18px);
         display:grid; gap:12px; }
  header{ display:flex; align-items:center; justify-content:space-between; gap:10px; }
  h1{ font-size: clamp(18px, 5vw, 26px); margin:0; }
  .badge{ font-size:13px; padding:8px 12px; border-radius:10px; border:1px solid #20242d;
          background:linear-gradient(180deg,#1a1d25,#13161b); }
  .hud{ display:grid; grid-template-columns: repeat(2,1fr); gap:10px; }
  @media (min-width:700px){ .hud{ grid-template-columns: repeat(5,1fr); } }
  .card{ background:linear-gradient(180deg,#181a20,#12141a); border:1px solid #232733; border-radius:14px;
         padding:12px; display:flex; align-items:center; justify-content:space-between;
         min-height:56px; }
  .big{ font-weight:800; font-size: clamp(18px, 6vw, 24px); }
  .controls{ display:flex; gap:8px; flex-wrap:wrap; }
  button{ flex:1 1 auto; min-width: 44%; padding:14px 16px; border-radius:12px; border:1px solid #2c3550;
          background:linear-gradient(180deg,#233048,#1a2436); color:var(--ink); font-weight:700; font-size:16px; }
  button.secondary{ background:linear-gradient(180deg,#2a2e35,#1b1e24); border-color:#3a3f49; }
  button:active{ transform: translateY(1px); }
  .canvas-wrap{ position:relative; border-radius:14px; padding:10px; border:1px solid #2a2f3a;
                background: radial-gradient(120% 120% at 50% 10%, #3f5e30, #284127); }
  canvas{ width:100%; height: min(70svh, 620px); display:block; border-radius:10px;
          background: radial-gradient(200% 80% at 50% 0%, #d7c6a2 0%, var(--terrain) 50%, #bda27a 100%);
          touch-action: none; }
  .overlay{ position:absolute; inset:0; display:none; place-items:center; pointer-events:none; }
  .overlay.show{ display:grid; }
  .modal{ pointer-events:auto; width:min(520px, 92%); border-radius:16px; padding:18px;
          border:1px solid #2a3341; background:linear-gradient(180deg,#18202b,#0f141b); text-align:center; }
  .modal h2{ margin:.2em 0 .4em; font-size: clamp(20px,6vw,26px); }
  .modal .scoreline{ font-size: clamp(15px,4.2vw,18px); color:var(--muted); margin-bottom:12px; }
  .help{ font-size:13px; color:var(--muted); }
  #err{ position:fixed; top:0; left:0; right:0; z-index:9999; display:none;
        background:#b00020; color:#fff; padding:10px 12px; font-weight:700; }
  .soundbtn{ margin-left:auto; background:linear-gradient(180deg,#263243,#1a2331);
             border:1px solid #344157; padding:10px 12px; border-radius:12px; font-size:16px; }
</style>
</head>
<body>
<div id="err"></div>

<div class="wrap">
  <header>
    <h1>P√©tanque ‚Äî Mobile</h1>
    <div class="badge">Cochonnet jaune ‚Ä¢ Bleu / Rouge</div>
    <button id="btnSound" class="soundbtn" aria-pressed="false" title="Activer le son">üîá</button>
  </header>

  <div class="hud">
    <div class="card"><div>Manche</div><div class="big" id="endNum">1</div></div>
    <div class="card"><div>Score Bleu</div><div class="big" id="scoreBlue">0</div></div>
    <div class="card"><div>Score Rouge</div><div class="big" id="scoreRed">0</div></div>
    <div class="card"><div>Joue</div><div class="big" id="turnText">Bleu</div></div>
    <div class="card"><div>Boules (B/R)</div><div class="big" id="ballsLeft">3 / 3</div></div>
  </div>

  <div class="controls">
    <button id="btnNewEnd">Nouvelle m√®ne</button>
    <button id="btnReset" class="secondary">Nouvelle partie</button>
    <button id="btnHelp" class="secondary">Aide</button>
  </div>

  <div class="canvas-wrap">
    <canvas id="game" aria-label="Terrain de p√©tanque"></canvas>
    <div class="overlay" id="overlay">
      <div class="modal">
        <h2 id="overlayTitle">Fin de m√®ne</h2>
        <div class="scoreline" id="overlayText"></div>
        <div class="controls">
          <button id="overlayNewEnd">Lancer la prochaine m√®ne</button>
          <button id="overlayReplay" class="secondary">Rejouer cette m√®ne</button>
        </div>
        <div class="help">Glisse depuis le cercle pour viser. Boule sur le rail = morte. Bouchon sur le rail = on rejoue.</div>
      </div>
    </div>
  </div>

  <div class="help">
    Premi√®re √©quipe √† <strong>13</strong> gagne. Optimis√© pour iPhone (tactile, anti-scroll pendant le tir).
  </div>
</div>

<script>
(()=> {
  const errBar = document.getElementById('err');
  const error = (msg)=>{ errBar.textContent = msg; errBar.style.display='block'; console.error('[P√©tanque]', msg); };

  // Canvas
  const canvas = document.getElementById('game');
  const ctx = canvas.getContext && canvas.getContext('2d');
  if(!ctx){ error('Canvas 2D non dispo.'); return; }

  // UI
  const ui = {
    endNum: document.getElementById('endNum'),
    scoreBlue: document.getElementById('scoreBlue'),
    scoreRed: document.getElementById('scoreRed'),
    turnText: document.getElementById('turnText'),
    ballsLeft: document.getElementById('ballsLeft'),
    overlay: document.getElementById('overlay'),
    overlayTitle: document.getElementById('overlayTitle'),
    overlayText: document.getElementById('overlayText'),
    overlayNewEnd: document.getElementById('overlayNewEnd'),
    overlayReplay: document.getElementById('overlayReplay'),
    btnNewEnd: document.getElementById('btnNewEnd'),
    btnReset: document.getElementById('btnReset'),
    btnHelp: document.getElementById('btnHelp'),
    btnSound: document.getElementById('btnSound'),
  };

  // --- Audio & vibrations ---
  const sfx = (()=> {
    const api = { enabled:false, ctx:null, gain:null };
    function ensureCtx(){
      if(api.ctx) return true;
      const AC = window.AudioContext || window.webkitAudioContext;
      if(!AC) return false;
      api.ctx = new AC();
      api.gain = api.ctx.createGain();
      api.gain.gain.value = 0.6;
      api.gain.connect(api.ctx.destination);
      return true;
    }
    function env(duration=0.15, type='sine', freq=440, vol=0.6, opts={}){
      if(!api.enabled || !ensureCtx()) return;
      const t0 = api.ctx.currentTime + (opts.delay||0);
      const osc = api.ctx.createOscillator();
      const g = api.ctx.createGain();
      osc.type = type;
      osc.frequency.setValueAtTime(freq, t0);
      if(opts.freqTo){ osc.frequency.exponentialRampToValueAtTime(opts.freqTo, t0+duration*0.9); }
      g.gain.setValueAtTime(0.0001, t0);
      g.gain.exponentialRampToValueAtTime(vol, t0+0.01);
      g.gain.exponentialRampToValueAtTime(0.0001, t0+duration);
      osc.connect(g); g.connect(api.gain);
      osc.start(t0); osc.stop(t0+duration+0.02);
    }
    function noise(duration=0.08, vol=0.5, lp=1500){
      if(!api.enabled || !ensureCtx()) return;
      const t0 = api.ctx.currentTime;
      const buffer = api.ctx.createBuffer(1, api.ctx.sampleRate*duration, api.ctx.sampleRate);
      const data = buffer.getChannelData(0);
      for(let i=0;i<data.length;i++) data[i] = (Math.random()*2-1)*0.9;
      const src = api.ctx.createBufferSource(); src.buffer=buffer;
      const biq = api.ctx.createBiquadFilter(); biq.type='lowpass'; biq.frequency.value=lp;
      const g = api.ctx.createGain();
      g.gain.setValueAtTime(vol, t0);
      g.gain.exponentialRampToValueAtTime(0.0001, t0+duration);
      src.connect(biq); biq.connect(g); g.connect(api.gain);
      src.start(t0);
    }
    function vibrate(ms){ if(navigator.vibrate) navigator.vibrate(ms); }

    return {
      toggle(){
        api.enabled = !api.enabled;
        if(api.enabled){ ensureCtx(); api.ctx.resume && api.ctx.resume(); }
        return api.enabled;
      },
      arm(){ // appel√© sur 1√®re interaction pour autoriser iOS
        if(!api.enabled){ api.enabled=true; ensureCtx(); }
      },
      play(name, strength=1){
        if(!api.enabled) return;
        switch(name){
          case 'ui': env(0.06,'triangle',600,0.25); break;
          case 'throw': noise(0.08,0.35,1800); env(0.09,'sine',380,0.15,{freqTo:300}); break;
          case 'hit': env(0.05,'square',220+Math.random()*60,0.25); vibrate(8); break;
          case 'dead': noise(0.09,0.45,900); env(0.08,'sine',130,0.18); vibrate(18); break;
          case 'jackOut': env(0.3,'sawtooth',500,0.18,{freqTo:160}); noise(0.12,0.3,1200); vibrate(25); break;
          case 'score': env(0.18,'sine',880,0.22); env(0.18,'sine',1320,0.15,{delay:0.04}); break;
          case 'win': env(0.22,'triangle',660,0.22); env(0.25,'triangle',990,0.22,{delay:0.12}); env(0.3,'triangle',1320,0.22,{delay:0.24}); break;
        }
      }
    };
  })();

  ui.btnSound.addEventListener('click', ()=>{
    const on = sfx.toggle();
    ui.btnSound.textContent = on ? 'üîä' : 'üîá';
    ui.btnSound.setAttribute('aria-pressed', on ? 'true' : 'false');
    sfx.play('ui');
  });

  // Activer l‚Äôaudio au premier geste utilisateur
  const armAudioOnce = ()=>{ sfx.arm(); window.removeEventListener('pointerdown', armAudioOnce); window.removeEventListener('touchstart', armAudioOnce); };
  window.addEventListener('pointerdown', armAudioOnce, {passive:true});
  window.addEventListener('touchstart', armAudioOnce, {passive:true});

  // State
  const COLORS = { blue:'#2d7ef7', red:'#ff4d4f', jack:'#ffcf4a', rim:'#0b0d12' };
  const state = {
    dpr: 1, w:0, h:0,
    margin: 26, rail: 12,
    friction: 180, ballRestitution: 0.75,
    maxSpeed: 1050,
    throwCircleR: 24, throwSpot: {x:0,y:0},
    phase: 'place_jack',
    balls: [], jack: null,
    currentTeam: 0, startingTeam: 0,
    boulesPerTeam: 3, left: [3,3],
    score: [0,0], endNum: 1,
    aiming: { active:false, power:0, maxDrag:180 },
    lastSnapshot: null, endStartSnapshot: null,
    motionLock: false,
    toasts: [],
    overlayMode: null,
  };

  // === Texture image "cover" ===
  let terrainImg = null, terrainReady = false;
  const IMAGE_HAS_RAILS = true; // ton photo-terrain inclut d√©j√† des bordures
  // Fallback sable proc√©dural
  let sandPattern = null;
  function buildProceduralSand(){
    const w=Math.max(512, Math.floor(state.w/1.5));
    const h=Math.max(512, Math.floor(state.h/1.5));
    const off=document.createElement('canvas'); off.width=w; off.height=h; const o=off.getContext('2d');
    function vnoise(x,y,seed=1337){ const n = Math.sin((x*127.1+y*311.7+seed)*0.0073)*43758.5453; return n - Math.floor(n); }
    function perlin(x,y){ const xi=Math.floor(x), yi=Math.floor(y), xf=x-xi, yf=y-yi;
      function g(u,v){ return vnoise(xi+u,yi+v); }
      const tl=g(0,0), tr=g(1,0), bl=g(0,1), br=g(1,1), u=xf*xf*(3-2*xf), v=yf*yf*(3-2*yf);
      return (tl*(1-u)+tr*u)*(1-v) + (bl*(1-u)+br*u)*v;
    }
    const img=o.createImageData(w,h); let k=0;
    for(let j=0;j<h;j++){
      for(let i=0;i<w;i++){
        const n = 0.6*perlin(i*0.06,j*0.06) + 0.3*perlin(i*0.12+1000,j*0.12+1000) + 0.1*perlin(i*0.24+2000,j*0.24+2000);
        const base=200 + (n*28|0);
        img.data[k++]=base; img.data[k++]=178 + (n*12|0); img.data[k++]=140 + (n*10|0); img.data[k++]=255;
      }
    }
    o.putImageData(img,0,0);
    const g=o.createRadialGradient(w/2,h*0.55, Math.min(w,h)*0.1, w/2,h*0.55, Math.max(w,h)*0.8);
    g.addColorStop(0,'rgba(255,255,255,.08)'); g.addColorStop(1,'rgba(0,0,0,.20)');
    o.fillStyle=g; o.fillRect(0,0,w,h);
    sandPattern = ctx.createPattern(off,'repeat');
  }
  function buildTextures(){
    terrainReady = false;
    terrainImg = new Image();
    terrainImg.onload  = ()=>{ terrainReady = true; };
    terrainImg.onerror = ()=>{ terrainReady = false; buildProceduralSand(); };
    terrainImg.src = 'terrain.jpg?cache=' + Date.now();
    sandPattern = null; buildProceduralSand();
  }

  // Utils
  const clamp=(x,a,b)=>Math.max(a,Math.min(b,x));
  const dist=(a,b)=>Math.hypot(a.x-b.x, a.y-b.y);

  class Ball{
    constructor(x,y,r,color,mass=1,kind='boule',team=-1){
      this.x=x; this.y=y; this.vx=0; this.vy=0; this.r=r;
      this.color=color; this.mass=mass; this.kind=kind; this.team=team;
      this.dead=false;
    }
    get speed(){ return Math.hypot(this.vx,this.vy); }
  }

  // DPI/size
  function resizeCanvas(){
    const cssW = canvas.clientWidth;
    const cssH = canvas.clientHeight;
    const dpr = Math.max(1, Math.min(3, window.devicePixelRatio || 1));
    canvas.width  = Math.round(cssW * dpr);
    canvas.height = Math.round(cssH * dpr);
    state.dpr = dpr; state.w = canvas.width; state.h = canvas.height;
    placeThrowSpot();
    buildTextures();
  }
  window.addEventListener('resize', resizeCanvas);
  window.addEventListener('orientationchange', ()=>{ setTimeout(resizeCanvas, 250); });

  function playBounds(){
    const m=state.margin*state.dpr, r=state.rail*state.dpr;
    const x=m+r, y=m+r, w=state.w-2*(m+r), h=state.h-2*(m+r);
    return {x,y,w,h};
  }
  function placeThrowSpot(){
    const b=playBounds();
    state.throwSpot.x = b.x + b.w*0.5;
    state.throwSpot.y = b.y + b.h*0.88;
  }

  // Snapshots
  function serializeSnapshot(){
    return JSON.stringify({
      phase: state.phase,
      balls: state.balls.map(b=>({x:b.x,y:b.y,vx:b.vx,vy:b.vy,r:b.r,color:b.color,mass:b.mass,kind:b.kind,team:b.team})),
      currentTeam: state.currentTeam,
      startingTeam: state.startingTeam,
      left: [...state.left],
      score: [...state.score],
      endNum: state.endNum
    });
  }
  function loadSnapshot(json){
    const s=JSON.parse(json);
    state.phase=s.phase;
    state.balls=s.balls.map(o=>{
      const b=new Ball(o.x,o.y,o.r,o.color,o.mass,o.kind,o.team);
      b.vx=o.vx; b.vy=o.vy; if(o.kind==='jack') state.jack=b; return b;
    });
    state.currentTeam=s.currentTeam;
    state.startingTeam=s.startingTeam;
    state.left=s.left;
    state.score=s.score;
    state.endNum=s.endNum;
    state.motionLock=false; hideOverlay(); updateUI();
  }

  // UI helpers
  const teamName=(i)=> i===0?'Bleue':'Rouge';
  function updateUI(){
    ui.endNum.textContent = state.endNum;
    ui.scoreBlue.textContent = state.score[0];
    ui.scoreRed.textContent = state.score[1];
    ui.turnText.textContent = state.currentTeam===0?'Bleu':'Rouge';
    ui.ballsLeft.textContent = `${state.left[0]} / ${state.left[1]}`;
  }
  function showOverlay(){ ui.overlay.classList.add('show'); }
  function hideOverlay(){ ui.overlay.classList.remove('show'); }
  function announceOverlay(title, text){ ui.overlayTitle.textContent=title; ui.overlayText.textContent=text; showOverlay(); }

  // Match control
  function resetMatch(){
    state.score=[0,0]; state.endNum=1; state.startingTeam = Math.random()<0.5?0:1;
    newEnd({isFirst:true});
  }
  function newEnd({ isFirst=false, silent=false } = {}){
    state.phase='place_jack';
    state.balls=[]; state.jack=null;
    state.left=[state.boulesPerTeam,state.boulesPerTeam];
    state.currentTeam=state.startingTeam;
    state.motionLock=false;
    updateUI();
    const snap=serializeSnapshot();
    state.endStartSnapshot=snap; state.lastSnapshot=snap;
    if(!isFirst && !silent){
      state.overlayMode=null;
      ui.overlayNewEnd.textContent='Lancer la prochaine m√®ne';
      ui.overlayReplay.textContent='Rejouer cette m√®ne';
      announceOverlay('Nouvelle m√®ne', `√Ä l‚Äô√©quipe ${teamName(state.currentTeam)} de poser le cochonnet.`);
    }
  }
  function replayEnd(){ if(state.lastSnapshot) loadSnapshot(state.lastSnapshot); }

  // Buttons
  ui.btnNewEnd.addEventListener('click', ()=>{ sfx.play('ui'); state.endNum++; newEnd(); });
  ui.btnReset.addEventListener('click', ()=>{ sfx.play('ui'); resetMatch(); hideOverlay(); });
  ui.overlayNewEnd.addEventListener('click', ()=>{ sfx.play('ui'); hideOverlay(); state.endNum++; newEnd({silent:true}); });
  ui.overlayReplay.addEventListener('click', ()=>{ sfx.play('ui'); hideOverlay(); replayEnd(); });
  ui.btnHelp.addEventListener('click', ()=>{ sfx.play('ui'); announceOverlay('Aide', '1) Pose le cochonnet depuis le cercle. 2) Joue les boules en glissant. La plus loin rejoue. Boule sur rail = morte. Bouchon sur rail = on rejoue. √Ä 13 = victoire.'); });

  // Effects (toasts)
  function addToast(text,x,y){ state.toasts.push({text,x,y,ttl:1.3}); }
  function updateEffects(dt){
    for(const t of state.toasts){ t.ttl-=dt; t.y-=20*dt*state.dpr; }
    state.toasts=state.toasts.filter(t=>t.ttl>0);
  }
  function drawToasts(){
    for(const t of state.toasts){
      const a=Math.min(1,Math.max(0,t.ttl/1.0));
      ctx.save(); ctx.globalAlpha=a; ctx.fillStyle='rgba(0,0,0,0.55)';
      const pad=6*state.dpr; ctx.font=`${12*state.dpr}px system-ui`;
      const m=ctx.measureText(t.text); const w=m.width+pad*2, h=20*state.dpr+pad*2;
      ctx.fillRect(t.x-w/2, t.y-h/2, w, h);
      ctx.fillStyle='white'; ctx.fillText(t.text, t.x-m.width/2, t.y+4*state.dpr);
      ctx.restore();
    }
  }

  // Physics
  function resolveCollision(a,b){
    const preRel = Math.hypot(b.vx-a.vx, b.vy-a.vy); // pour jauger la force
    const dx=b.x-a.x, dy=b.y-a.y, d=Math.hypot(dx,dy), min=a.r+b.r;
    if(d===0||d>min) return;
    const overlap=(min-d)+0.01, nx=dx/(d||1), ny=dy/(d||1), tm=a.mass+b.mass;
    a.x-=nx*overlap*(b.mass/tm); a.y-=ny*overlap*(b.mass/tm);
    b.x+=nx*overlap*(a.mass/tm); b.y+=ny*overlap*(a.mass/tm);
    const rvx=b.vx-a.vx, rvy=b.vy-a.vy, vn=rvx*nx+rvy*ny;
    if(vn<=0){
      const e=state.ballRestitution || 0.75, j=-(1+e)*vn/(1/a.mass+1/b.mass), ix=j*nx, iy=j*ny;
      a.vx-=ix/a.mass; a.vy-=iy/a.mass; b.vx+=ix/b.mass; b.vy+=iy/b.mass;
      if(preRel>120){ sfx.play('hit'); }
    }
  }
  function anyMoving(){ for(const b of state.balls){ if(b.speed>5) return true; } return false; }

  function updatePhysics(dt){
    const bounds=playBounds();
    for(const b of state.balls){
      if(b.dead) continue;
      const s=b.speed;
      if(s>0){
        const dec=state.friction*dt;
        if(s<=dec){ b.vx=0; b.vy=0; }
        else { const f=1-dec/s; b.vx*=f; b.vy*=f; }
      }
      b.x+=b.vx*dt; b.y+=b.vy*dt;

      if(b.kind==='boule'){
        if(b.x-b.r<=bounds.x||b.x+b.r>=bounds.x+b.w||b.y-b.r<=bounds.y||b.y+b.r>=bounds.y+b.h){
          b.dead=true;
          addToast('Boule morte', b.x, b.y-18*state.dpr);
          sfx.play('dead');
          b.vx=0; b.vy=0; continue;
        }
      } else {
        if(b.x-b.r<=bounds.x||b.x+b.r>=bounds.x+b.w||b.y-b.r<=bounds.y||b.y+b.r>=bounds.y+b.h){
          sfx.play('jackOut');
          announceOverlay('M√®ne annul√©e','Le cochonnet a touch√© le bord. On rejoue en reposant le cochonnet.');
          setTimeout(()=>{ hideOverlay(); newEnd({silent:true}); }, 700);
          state.motionLock=false; return;
        }
      }
    }
    if(state.balls.some(b=>b.dead)) state.balls=state.balls.filter(b=>!b.dead);

    for(let i=0;i<state.balls.length;i++){
      const a=state.balls[i];
      for(let j=i+1;j<state.balls.length;j++){
        const b=state.balls[j];
        resolveCollision(a,b);
      }
    }
    updateEffects(dt);
  }

  // Turn & scoring
  function nearestDist(team){
    const jack=state.jack; if(!jack) return Infinity;
    let best=Infinity;
    for(const b of state.balls){ if(b.kind==='boule'&&b.team===team){ const d=dist(b,jack); if(d<best) best=d; } }
    return best;
  }
  function decideNextTeam(){
    const L=state.left, d0=nearestDist(0), d1=nearestDist(1);
    if(!isFinite(d0)&&!isFinite(d1)){
      if(L[state.currentTeam]>0) return state.currentTeam;
      if(L[1-state.currentTeam]>0) return 1-state.currentTeam;
    }else{
      let farTeam=d0>d1?0:1;
      if(Math.abs(d0-d1)<0.1) farTeam=state.currentTeam;
      if(L[farTeam]>0) return farTeam;
      if(L[1-farTeam]>0) return 1-farTeam;
    }
    return null;
  }
  function scoreEnd(){
    const dB=nearestDist(0), dR=nearestDist(1);
    let winner= (dR<dB)?1:0;
    if(!isFinite(dB)&&isFinite(dR)) winner=1;
    if(!isFinite(dR)&&isFinite(dB)) winner=0;
    const oppBest = winner===0?dR:dB;
    let points=0;
    for(const b of state.balls){
      if(b.kind==='boule'&&b.team===winner){
        if(dist(b,state.jack)+0.05<oppBest) points++;
      }
    }
    return {winner, points};
  }
  function showScoreOverlay({winner,points}){
    const team = winner===0?'Bleue':'Rouge';
    state.overlayMode='end';
    ui.overlayNewEnd.textContent='Lancer la prochaine m√®ne';
    ui.overlayReplay.textContent='Rejouer cette m√®ne';
    announceOverlay('Fin de m√®ne', `√âquipe ${team} marque ${points} point${points>1?'s':''}. Score ‚Äî Bleu: ${state.score[0]} / Rouge: ${state.score[1]}.`);
    sfx.play('score');
  }
  function showMatchWin(winner){
    const team = winner===0?'Bleue':'Rouge';
    state.phase='match_over';
    state.overlayMode='win';
    ui.overlayNewEnd.textContent='Rejouer la partie';
    ui.overlayReplay.textContent='Revoir la derni√®re m√®ne';
    announceOverlay('Partie gagn√©e', `Bravo ! L‚Äô√©quipe ${team} atteint 13. Score final ‚Äî Bleu: ${state.score[0]} / Rouge: ${state.score[1]}.`);
    sfx.play('win');
  }
  function afterMotionSettled(){
    if(state.phase==='place_jack'){
      state.phase='play';
      state.currentTeam=state.startingTeam;
      state.motionLock=false; updateUI(); return;
    }
    if(state.phase!=='play') return;
    const next=decideNextTeam();
    if(next===null){
      const res=scoreEnd();
      state.score[res.winner]+=res.points;
      if(state.score[res.winner] >= 13){ showMatchWin(res.winner); return; }
      state.startingTeam=res.winner;
      updateUI(); showScoreOverlay(res);
      state.phase='scoring'; state.motionLock=false;
    } else {
      state.currentTeam=next; state.motionLock=false; updateUI();
    }
  }

  // Input ‚Äî Pointer Events + fallback Touch (pointe)
  const pointer = { x:0, y:0 };
  function ptFromEvent(e){
    const r=canvas.getBoundingClientRect();
    let x, y;
    if(e.touches && e.touches[0]){ x = e.touches[0].clientX; y = e.touches[0].clientY; }
    else if(e.changedTouches && e.changedTouches[0]){ x = e.changedTouches[0].clientX; y = e.changedTouches[0].clientY; }
    else { x = e.clientX; y = e.clientY; }
    return { x:(x-r.left)*state.dpr, y:(y-r.top)*state.dpr };
  }

  function onStart(e){
    e.preventDefault();
    if(state.motionLock||anyMoving()) return;
    const p = ptFromEvent(e); pointer.x=p.x; pointer.y=p.y;
    state.aiming.active=true; state.aiming.power=0;
  }
  function onMove(e){
    if(!state.aiming.active) return;
    e.preventDefault();
    const p = ptFromEvent(e); pointer.x=p.x; pointer.y=p.y;
    const dx=state.throwSpot.x-pointer.x, dy=state.throwSpot.y-pointer.y;
    const drag=clamp(Math.hypot(dx,dy),0,state.aiming.maxDrag*state.dpr);
    state.aiming.power = drag/(state.aiming.maxDrag*state.dpr);
  }
  function onEnd(e){
    if(!state.aiming.active) return;
    e.preventDefault();
    if(state.motionLock||anyMoving()){ state.aiming.active=false; return; }
    state.aiming.active=false;

    const p = ptFromEvent(e);
    const dx=state.throwSpot.x-p.x, dy=state.throwSpot.y-p.y;
    const drag=Math.hypot(dx,dy); if(drag<8*state.dpr) return;
    const dirx=dx/drag, diry=dy/drag;
    const speed=clamp(state.maxSpeed*(drag/(state.aiming.maxDrag*state.dpr)),120,state.maxSpeed);

    if(state.phase==='place_jack'){
      if(!state.jack){
        const r=6*state.dpr; const jack=new Ball(state.throwSpot.x,state.throwSpot.y,r,COLORS.jack,0.5,'jack',-1);
        state.jack=jack; state.balls.push(jack);
      }
      state.jack.vx=dirx*speed; state.jack.vy=diry*speed; state.motionLock=true;
      sfx.play('throw');
    } else if(state.phase==='play'){
      if(!state.jack){ addToast('Pose d‚Äôabord le cochonnet', state.throwSpot.x, state.throwSpot.y-24*state.dpr); return; }
      if(state.left[state.currentTeam]<=0) return;
      const r=12*state.dpr; const col=state.currentTeam===0?COLORS.blue:COLORS.red;
      const boule=new Ball(state.throwSpot.x,state.throwSpot.y,r,col,1.8,'boule',state.currentTeam);
      boule.vx=dirx*speed; boule.vy=diry*speed; state.balls.push(boule);
      state.left[state.currentTeam]--; state.motionLock=true;
      sfx.play('throw');
    }
    updateUI();
  }

  if('onpointerdown' in window){
    canvas.addEventListener('pointerdown', onStart, {passive:false});
    canvas.addEventListener('pointermove', onMove, {passive:false});
    window.addEventListener('pointerup', onEnd, {passive:false});
  } else {
    canvas.addEventListener('touchstart', onStart, {passive:false});
    canvas.addEventListener('touchmove', onMove, {passive:false});
    window.addEventListener('touchend', onEnd, {passive:false});
    window.addEventListener('touchcancel', (e)=>{ state.aiming.active=false; }, {passive:true});
  }

  // ====== Rendu ======
  function draw(){
    const {w,h}=state;
    ctx.clearRect(0,0,w,h);
    drawTerrain(); drawThrowCircle();
    drawScoreOverlayOnField();
    for(const b of state.balls) drawBall(b);
    if(state.aiming.active) drawAim();
    drawTurnMarker(); drawToasts();
  }

  function drawTerrain(){
    const b=playBounds();

    if (terrainReady && terrainImg){
      if (!IMAGE_HAS_RAILS){ drawRails(b); }
      const iw=terrainImg.naturalWidth, ih=terrainImg.naturalHeight;
      const rImg=iw/ih, rDst=b.w/b.h;
      let dw, dh, dx, dy;
      if (rImg > rDst){ dh=b.h; dw=dh*rImg; }
      else { dw=b.w; dh=dw/rImg; }
      dx=b.x+(b.w-dw)/2; dy=b.y+(b.h-dh)/2;
      ctx.drawImage(terrainImg, dx, dy, dw, dh);

      const ao=22*state.dpr;
      let gL=ctx.createLinearGradient(b.x,b.y,b.x+ao,b.y); gL.addColorStop(0,'rgba(0,0,0,.28)'); gL.addColorStop(1,'rgba(0,0,0,0)');
      ctx.fillStyle=gL; ctx.fillRect(b.x,b.y,ao,b.h);
      let gR=ctx.createLinearGradient(b.x+b.w,b.y,b.x+b.w-ao,b.y); gR.addColorStop(0,'rgba(0,0,0,.26)'); gR.addColorStop(1,'rgba(0,0,0,0)');
      ctx.fillStyle=gR; ctx.fillRect(b.x+b.w-ao,b.y,ao,b.h);
      let gT=ctx.createLinearGradient(0,b.y,0,b.y+ao); gT.addColorStop(0,'rgba(0,0,0,.30)'); gT.addColorStop(1,'rgba(0,0,0,0)');
      ctx.fillStyle=gT; ctx.fillRect(b.x,b.y,b.w,ao);
      let gB=ctx.createLinearGradient(0,b.y+b.h,0,b.y+b.h-ao); gB.addColorStop(0,'rgba(0,0,0,.22)'); gB.addColorStop(1,'rgba(0,0,0,0)');
      ctx.fillStyle=gB; ctx.fillRect(b.x,b.y+b.h-ao,b.w,ao);
      return;
    }

    // Fallback : rails + sable proc√©dural
    drawRails(b);
    if(!sandPattern){ buildProceduralSand(); }
    ctx.save(); ctx.beginPath(); ctx.rect(b.x,b.y,b.w,b.h); ctx.fillStyle=sandPattern; ctx.fill();

    const ao=22*state.dpr;
    let gL2=ctx.createLinearGradient(b.x,b.y,b.x+ao,b.y); gL2.addColorStop(0,'rgba(0,0,0,.32)'); gL2.addColorStop(1,'rgba(0,0,0,0)');
    ctx.fillStyle=gL2; ctx.fillRect(b.x,b.y,ao,b.h);
    let gR2=ctx.createLinearGradient(b.x+b.w,b.y,b.x+b.w-ao,b.y); gR2.addColorStop(0,'rgba(0,0,0,.30)'); gR2.addColorStop(1,'rgba(0,0,0,0)');
    ctx.fillStyle=gR2; ctx.fillRect(b.x+b.w-ao,b.y,ao,b.h);
    let gT2=ctx.createLinearGradient(0,b.y,0,b.y+ao); gT2.addColorStop(0,'rgba(0,0,0,.33)'); gT2.addColorStop(1,'rgba(0,0,0,0)');
    ctx.fillStyle=gT2; ctx.fillRect(b.x,b.y,b.w,ao);
    let gB2=ctx.createLinearGradient(0,b.y+b.h,0,b.y+b.h-ao); gB2.addColorStop(0,'rgba(0,0,0,.28)'); gB2.addColorStop(1,'rgba(0,0,0,0)');
    ctx.fillStyle=gB2; ctx.fillRect(b.x,b.y+b.h-ao,b.w,ao);
    ctx.restore();
  }

  function drawRails(b){
    const r=state.rail*state.dpr;
    ctx.save();
    const g=ctx.createLinearGradient(b.x-r,b.y,b.x,b.y);
    g.addColorStop(0,'#5f4728'); g.addColorStop(1,'#7a5d37');
    ctx.fillStyle=g;
    ctx.fillRect(b.x-r, b.y-r, b.w+2*r, r);
    ctx.fillRect(b.x-r, b.y+b.h, b.w+2*r, r);
    ctx.fillRect(b.x-r, b.y, r, b.h);
    ctx.fillRect(b.x+b.w, b.y, r, b.h);
    ctx.restore();
  }

  // Score incrust√© (arri√®re-plan du terrain)
  function drawScoreOverlayOnField(){
    const b=playBounds();
    const label=`Bleu ${state.score[0]} ‚Äî ${state.score[1]} Rouge`;
    ctx.save();
    ctx.globalAlpha=0.22;
    ctx.fillStyle='#000';
    ctx.font = `${Math.max(20*state.dpr, b.w*0.055)}px ui-sans-serif, system-ui`;
    ctx.textAlign='center'; ctx.textBaseline='top';
    const x=b.x + b.w/2, y=b.y + 16*state.dpr;
    ctx.fillText(label, x+1.5*state.dpr, y+1.5*state.dpr);
    ctx.globalAlpha=0.32;
    const grad=ctx.createLinearGradient(0,y,0,y+40*state.dpr);
    grad.addColorStop(0,'rgba(255,255,255,.80)');
    grad.addColorStop(1,'rgba(255,255,255,.35)');
    ctx.fillStyle=grad;
    ctx.fillText(label, x, y);
    ctx.restore();
  }

  function drawBall(b){
    ctx.save(); ctx.shadowColor='rgba(0,0,0,.35)'; ctx.shadowBlur=8*state.dpr; ctx.shadowOffsetY=2*state.dpr;
    ctx.beginPath(); ctx.arc(b.x,b.y,b.r,0,Math.PI*2); ctx.fillStyle=b.color; ctx.fill(); ctx.restore();
    ctx.beginPath(); ctx.arc(b.x,b.y,b.r,0,Math.PI*2); ctx.lineWidth=2*state.dpr; ctx.strokeStyle=COLORS.rim; ctx.stroke();
    const grad=ctx.createRadialGradient(b.x-b.r*0.4, b.y-b.r*0.4, b.r*0.2, b.x,b.y,b.r);
    grad.addColorStop(0,'rgba(255,255,255,.45)'); grad.addColorStop(1,'rgba(255,255,255,0)');
    ctx.fillStyle=grad; ctx.beginPath(); ctx.arc(b.x,b.y,b.r,0,Math.PI*2); ctx.fill();
  }
  function drawThrowCircle(){
    const c=state.throwSpot, R=state.throwCircleR*state.dpr;
    ctx.save();
    ctx.beginPath(); ctx.arc(c.x,c.y,R,0,Math.PI*2); ctx.strokeStyle='rgba(10,12,16,.65)'; ctx.lineWidth=3*state.dpr; ctx.stroke();
    ctx.beginPath(); ctx.arc(c.x,c.y,R-3*state.dpr,0,Math.PI*2); ctx.setLineDash([6*state.dpr,8*state.dpr]); ctx.strokeStyle='rgba(255,255,255,.18)'; ctx.lineWidth=1.5*state.dpr; ctx.stroke();
    ctx.restore();
  }
  function drawTurnMarker(){
    const c=state.throwSpot, R=state.throwCircleR*state.dpr, col=state.currentTeam===0?COLORS.blue:COLORS.red;
    ctx.save(); ctx.beginPath(); ctx.arc(c.x, c.y-R-10*state.dpr, 6*state.dpr, 0, Math.PI*2); ctx.fillStyle=col; ctx.fill(); ctx.restore();
  }
  function drawAim(){
    const c=state.throwSpot, dx=c.x-pointer.x, dy=c.y-pointer.y;
    const L=clamp(Math.hypot(dx,dy),0,state.aiming.maxDrag*state.dpr), dirx=dx/(L||1), diry=dy/(L||1);
    ctx.save(); ctx.lineCap='round'; ctx.lineJoin='round'; ctx.strokeStyle='rgba(255,255,255,.85)'; ctx.lineWidth=3*state.dpr;
    ctx.beginPath(); ctx.moveTo(c.x,c.y); ctx.lineTo(c.x-dirx*L, c.y-diry*L); ctx.stroke();
    const ax=c.x-dirx*L, ay=c.y-diry*L, head=10*state.dpr+4*state.aiming.power;
    ctx.beginPath(); ctx.moveTo(ax,ay); ctx.lineTo(ax+(-diry)*head, ay+(dirx)*head); ctx.lineTo(ax+(diry)*head, ay+(-dirx)*head); ctx.closePath(); ctx.fillStyle='rgba(255,255,255,.85)'; ctx.fill();
    const bw=130*state.dpr, bh=8*state.dpr, px=c.x-bw/2, py=c.y+(state.throwCircleR+14)*state.dpr;
    ctx.fillStyle='rgba(255,255,255,.15)'; ctx.fillRect(px,py,bw,bh);
    ctx.fillStyle= state.phase==='place_jack' ? COLORS.jack : (state.currentTeam===0?COLORS.blue:COLORS.red);
    ctx.fillRect(px,py,bw*state.aiming.power,bh);
    ctx.restore();
  }

  // Game loop
  let last=performance.now();
  function loop(now){
    const dt=Math.min(0.033,(now-last)/1000); last=now;
    updatePhysics(dt); draw();
    if(state.motionLock && !anyMoving()){ state.motionLock=false; afterMotionSettled(); }
    requestAnimationFrame(loop);
  }

  // Start
  resizeCanvas(); updateUI(); resetMatch(); requestAnimationFrame(loop);
})();
</script>
</body>
</html>